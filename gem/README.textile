h1. Guard the Rails Controller Actions

h2. installation

p. just add

bc.         gem 'ixtlan-guard'

p. into your _Gemfile_

h2. how it works

p. the main idea is like a posix authorization with a user belonging to one or more groups. each rails controller gets a *Guard* which maps each action of the controller to a set of allowed groups.

p. the default block which retrieves the logged in user from *current_user* method of the controller and collect the groups of this user. which makes it compatible with _restful_authentication_. in case there are no current_user the Guard will allow everything assuming there have no authentication and no authorization for this controller.

bc.        Proc.new do |controller|
          user = controller.send :current_user
          user.groups if user
        end

p. you can define a superuser group which default is *root* and that group is implicit added to all guards.

bc.         class UsersGuard
          def initialize(guard)
            guard.aliases = {:new=>:create, :edit=>:update}
            guard.actions= {
              :index => [:users],
              :show => [:users],
              :create => [:users],
              :update => [:users],
              :destroy => [:users]
            }
          end
        end


h2. restrict the access even further

p. assume you can translate your web application and have a translator group but you want to restrict each translator to its language. then you can use the guard to enforce this restriction.

p. let's add the following to your TranslationsController

bc. before :locale_authorization
    skip-before-filter :authorization
    def locale_authorization
      current_locale = params[:locale]
      authorization do |group| 
        if controller.respond_to? :current_user
          user = self.send :current_user
          GroupsLocalesUsers.first(:user => user, :group.name => group, :locale.name => current_locale)
          end
	end
      end
    end

p. this you can easily use for other use cases like having different domains. each domain has its own set of users. even allowing users to be associated with more then one domain.

h2. allowed? method in controller/view

p. both the rails controller as well the view have a methods *allowed?* to ask the guard if a particular action is allowed by the *current_user*.

p. the controller *allowed?* just needs the action as argument.

p. the view *allowed?* needs the resource name and the action to answer the quest.

h2. rails3 generators

p. per default the *scaffold*, *resource* and *controller* will add a guard for the actions of the generated controller. the views of the scaffold will use *allowed?* to determine if a link or button leads to an action which is allowed for the *current_user*
